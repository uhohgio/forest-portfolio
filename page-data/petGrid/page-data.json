{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/petGrid/","result":{"data":{"markdownRemark":{"html":"<h2>Introduction</h2>\n<p>In our pet adoption app, one of the core UI patterns is a grid of pet profile cards. Think of it like an online store, but instead of products, weâ€™re displaying adoptable pets.</p>\n<p>We needed a <strong>reusable</strong> solution that would work in multiple contexts:</p>\n<ul>\n<li>Browsing all pets</li>\n<li>Viewing pets for a specific shelter</li>\n<li>Showing filtered results (e.g., only puppies, only cats, etc.)</li>\n</ul>\n<p>Iâ€™ll walk through <strong>why</strong> we built it the way we did, <strong>how</strong> the data flows, and <strong>what patterns</strong> we used to keep it clean and maintainable. At the end, youâ€™ll see a diagram of the whole process.</p>\n<hr>\n<h2>The Problem</h2>\n<p>A \"PetCard\" in our app is a small, clickable React component. It shows the petâ€™s photo, name, and some quick info, and when clicked, navigates to the petâ€™s profile page.</p>\n<p>We wanted a grid of these PetCards,  <strong>PetGrid</strong> , that:</p>\n<ol>\n<li><strong>Could adapt to different contexts</strong> without rewriting logic each time.</li>\n<li><strong>Fetched pet data dynamically</strong> (so we werenâ€™t hardcoding lists anywhere).</li>\n<li><strong>Stayed clean, modular, and maintainable</strong>, even as new features got added.</li>\n</ol>\n<hr>\n<h2>Why Not Just Build It Once and Reuse It Everywhere?</h2>\n<p>If we simply hardcoded PetGrid to always fetch all pets, weâ€™d run into problems:</p>\n<ul>\n<li>On a shelterâ€™s profile page, weâ€™d still be fetching every pet, then manually filtering them in each place we used the grid.</li>\n<li>In the browse section, weâ€™d need <em>different</em> filtering logic (size, breed, age, etc.).</li>\n<li>If the filtering logic changed, weâ€™d have to update it in multiple places (not ideal for long-term maintenance).</li>\n</ul>\n<p>So instead, we made <strong>PetGrid dumb and flexible</strong> â€” meaning it doesnâ€™t decide what pets to show on its own. The logic comes from outside.</p>\n<hr>\n<h2>The Solution: Passing in <code>filters</code></h2>\n<p>We decided to <strong>outsource the decision-making</strong>.</p>\n<p>PetGrid accepts an object called <code>filters</code> that describes <em>what</em> pets it should display. This <code>filters</code> object is created or updated by other components (like PetFilter or ShelterProfile) depending on the current context.</p>\n<p>Hereâ€™s the mental model:</p>\n<ul>\n<li><strong>PetGrid</strong> is the <strong>chef</strong>.</li>\n<li><strong>Fetched data</strong> is the <strong>ingredients</strong>.</li>\n<li><strong>Filters</strong> are the <strong>recipe instructions</strong>.</li>\n</ul>\n<p>PetGrid takes the data, applies the filters, and produces a grid of PetCards.</p>\n<hr>\n<h3>Step-by-Step Flow</h3>\n<ol>\n<li><strong>Data Fetching</strong> â€“ PetGrid calls the API to fetch a list of pets.</li>\n<li><strong>Filtering</strong> â€“ PetGrid applies the <code>filters</code> object to decide which pets to include.</li>\n<li><strong>Card Rendering</strong> â€“ For each pet that passes the filters, PetGrid renders a PetCard.</li>\n<li><strong>Context Changes</strong> â€“ If another component updates <code>filters</code>, PetGrid re-renders with the new filtered list.</li>\n</ol>\n<p>ğŸ¶ API Fetch â†’ ğŸ“‹ PetGrid â†’ ğŸ” Apply Filters â†’ ğŸ–¼ï¸ Render Cards</p>\n<hr>\n<h3>In-App Examples</h3>\n<p><strong>Scenario 1: Shelter Profile Page</strong></p>\n<ul>\n<li>The <code>filters</code> object contains <code>{ shelterId: \"abc123\" }</code>.</li>\n<li>PetGrid fetches all pets but only shows ones from that shelter.</li>\n</ul>\n<p><strong>Scenario 2: Browse Pets Page</strong></p>\n<ul>\n<li>A <code>PetFilter</code> component lets the user select preferences (species, age, size).</li>\n<li>These preferences update <code>filters</code>, which PetGrid uses to re-render the grid.</li>\n</ul>\n<hr>\n<h2>The Pattern</h2>\n<p>This approach is similar to <strong>functional programming</strong>:</p>\n<ul>\n<li>Instead of embedding filtering logic inside PetGrid, we <em>pass it in</em> as data.</li>\n<li>PetGridâ€™s job is purely to <strong>take data â†’ apply filters â†’ render components</strong>.</li>\n</ul>\n<p><strong>Important to note:</strong> that we are not strictly doing functional programming here. This pattern simply borrows from functional programming ideas.</p>\n<p>In our case, the <code>filters</code> object is a set of rules rather than an actual function, but the spirit is similar: the behavior is controlled <strong>externally</strong> rather than being hardcoded inside.</p>\n<pre><code>// How filters are applied in the PetGrid component\r\n\r\nconst filteredPets = petList.filter((pet) => {\r\n  for (const key in filters) {\r\n    const filterValue = filters[key];\r\n    if (filterValue === '' || filterValue === false) continue;\r\n    return pet[key] === filterValue;\r\n  }\r\n  return true;\r\n});\n</code></pre>\n<p>By separating <strong>what to render</strong> (filters) from <strong>how to render it</strong> (PetGrid), we make the component easier to test, maintain, and reuse.</p>\n<hr>\n<h2>Conclusion</h2>\n<p>By passing filters into PetGrid instead of hardcoding logic, we ended up with a component thatâ€™s:</p>\n<ul>\n<li><strong>Reusable</strong> in multiple contexts.</li>\n<li><strong>Easier to maintain</strong> because filtering logic is centralized elsewhere.</li>\n<li><strong>Cleaner</strong> in its separation of concerns.</li>\n</ul>\n<p>Itâ€™s a small architectural choice, but itâ€™s one of those patterns that keeps your React codebase sane as your app grows.</p>","frontmatter":{"title":"How I Built the Pet Grid for Our Pet Adoption App","date":"August 13, 2025","tags":["React","UI/UX","Design","Tutorial"]}}},"pageContext":{"slug":"/petGrid/"}},"staticQueryHashes":["63159454"],"slicesMap":{}}